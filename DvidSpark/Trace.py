__author__ = 'gbw'

import Local_Neuroseg
import os
import sys
import datetime
import numpy as np
import Dvid_Access
import math

def getSeeds(file_url):
    file = open(file_url + "/" + uuid + "_seeds.swc")
    seeds = []
    line = file.readline()
    while len(line) > 0:
        line = file.readline()
        words = line.split(' ')
        if len(words) > 6:
            x = int(words[2])
            y = int(words[3])
            z = int(words[4])
            r = float(words[5])
            seed = (x, y, z, r)
            seeds.append(seed)
    return seeds

def writeOptimizeAns(file_url, scores):
    file_output = open(file_url + "/scores.txt", 'w')
    num = len(scores)
    for i in range(num):
        for j in range(11):
            file_output.write(str(scores[i][1][j]))
            file_output.write(" ")
        file_output.write(str(scores[i][0]))
        file_output.write("\n")

def SaveSwcFile(file_url, Neurosegs, seeds):
    n = len(Neurosegs)
    for i in range(n):
        file_output = open(file_url + "/" + str(i) + "_out.swc", 'w')
        file_output.write("# Generated by GBW\n")
        file_output.write("# Seed:")
        for k in range(4):
            file_output.write(str(seeds[i][k]))
            file_output.write(" ")
        file_output.write("\n")

        m = len(Neurosegs[i])
        num = 0
        for j in range(m):
            file_output.write(str(num+1))
            file_output.write(" ")
            file_output.write(str(0))
            file_output.write(" ")
            file_output.write(str(Neurosegs[i][j][8]))
            file_output.write(" ")
            file_output.write(str(Neurosegs[i][j][9]))
            file_output.write(" ")
            file_output.write(str(Neurosegs[i][j][10]))
            file_output.write(" ")
            file_output.write(str(Neurosegs[i][j][0]))
            file_output.write(" ")
            if num == 0:
                file_output.write(str(-1))
            else:
                file_output.write(str(num))
            num += 1
            file_output.write("\n")
        file_output.close()


def fit(locseg):
    fs_n = 2
    fs_options = np.array([0, 1])
    fs_pos_adjust = 1
    fs_scores = np.zeros(2)

    ball = np.zeros(4)
    Local_Neuroseg.Local_Neuroseg_Ball_Bound(locseg, ball)
    ball[3] *= 2
    stack = Dvid_Access.readStack(ball[0], ball[1], ball[2], ball[3], address.value, port.value, uuid.value)
    score = -1

    # a,b,c,d = stack.shape
    # print stack.reshape(a*b*c*d)[0:300]

    if stack.size > 0:
        stack_offset = np.zeros(3)
        stack_offset[0] = math.floor(ball[0] - ball[3])
        stack_offset[1] = math.floor(ball[1] - ball[3])
        stack_offset[2] = math.floor(ball[2] - ball[3])
        Dvid_Access.registerToRawStack(stack_offset, locseg)

        Local_Neuroseg.Fit_Local_Neuroseg_W(locseg, stack, 1.0, fs_n, fs_options, fs_scores, fs_pos_adjust)
        Dvid_Access.registerToStack(stack_offset, locseg)
        score = fs_scores[1]
    return score

def Spark_Optimize(ball):
    fs_n = 2
    fs_options = np.array([0, 1])
    fs_pos_adjust = 1
    fs_scores = np.zeros(2)

    x = ball[0]
    y = ball[1]
    z = ball[2]
    r = ball[3]

    locseg = Local_Neuroseg.New_Local_Neuroseg()
    Local_Neuroseg.Set_Local_Neuroseg(locseg, x, y, z, r)

    # print locseg

    ball = np.zeros(4)
    Local_Neuroseg.Local_Neuroseg_Ball_Bound(locseg, ball)

    ball[3] *= 3.0
    # print ball

    stack = Dvid_Access.readStack(ball[0], ball[1], ball[2], ball[3], address.value, port.value, uuid.value)

    # print stack.reshape(35*35*35)[6000:6100]
    # print stack.shape
    # print stack

    box = np.zeros(6)
    box[0] = math.floor(ball[0] - ball[3])
    box[1] = math.floor(ball[1] - ball[3])
    box[2] = math.floor(ball[2] - ball[3])
    # box[3] = math.ceil(ball[0] + ball[3]) + 1
    # box[4] = math.ceil(ball[1] + ball[3]) + 1
    # box[5] = math.ceil(ball[2] + ball[3]) + 1
    stack_offset = np.zeros(3)
    stack_offset[0] = math.floor(box[0])
    stack_offset[1] = math.floor(box[1])
    stack_offset[2] = math.floor(box[2])

    # print stack_offset

    score = -1.0

    if stack.size > 0:

        Dvid_Access.registerToRawStack(stack_offset, locseg)

        # ls = np.zeros(12)
        # for i in range(11):
        #     ls[i] = locseg[i]
        # ls[11] = 1.0
        # locseg = ls

        # print locseg

        # print stack.reshape(35*35*35)[999:1999]
        # print stack.shape

        Local_Neuroseg.Local_Neuroseg_Optimize_W(locseg, stack, 1.0, 0)

        # print locseg

        Local_Neuroseg.Flip_Local_Neuroseg(locseg)

        Local_Neuroseg.Fit_Local_Neuroseg_W(locseg, stack, 1.0, fs_n, fs_options, fs_scores, fs_pos_adjust)

        Local_Neuroseg.Flip_Local_Neuroseg(locseg)
        Local_Neuroseg.Fit_Local_Neuroseg_W(locseg, stack, 1.0, fs_n, fs_options, fs_scores, fs_pos_adjust)
        Dvid_Access.registerToStack(stack_offset, locseg)

        # print fs_scores
        score = fs_scores[1]

    segOptimize = np.zeros(12)
    segOptimize[0:11] = locseg
    segOptimize[11] = score

    return segOptimize

def Spark_Trace(Neuroseg):
    score = Neuroseg[0]
    locseg = Neuroseg[1]

    m_locsegList = []
    if score > 0.3:
        m_locsegList.append(locseg)
        tailSeg = [0 for i in range(11)]
        headSeg = [0 for i in range(11)]
        for i in range(11):
            tailSeg[i] = m_locsegList[len(m_locsegList)-1][i]
            headSeg[i] = m_locsegList[0][i]

        while (len(tailSeg) > 0) | (len(headSeg) > 0):
            if len(tailSeg) > 0:
                locseg = Local_Neuroseg.Next_Local_Neuroseg(tailSeg, 0.5)
                score = fit(locseg)
                if (score >= 0.3) & (Local_Neuroseg.hitTraced(locseg, m_locsegList) == False):
                    m_locsegList.append(locseg)
                    tailSeg = locseg
                else:
                    tailSeg = np.zeros(0)
            if len(headSeg) > 0:
                Local_Neuroseg.Flip_Local_Neuroseg(headSeg)
                locseg = Local_Neuroseg.Next_Local_Neuroseg(headSeg, 0.5)
                Local_Neuroseg.Flip_Local_Neuroseg(locseg)
                score = fit(locseg)
                # print locseg
                # print score
                if (score >= 0.3) & (Local_Neuroseg.hitTraced(locseg, m_locsegList) == False):
                    Local_Neuroseg.Flip_Local_Neuroseg(locseg)
                    m_locsegList.insert(0, locseg)
                    headSeg = locseg
                else:
                    headSeg = np.zeros(0)
    return m_locsegList

if __name__ == '__main__':
    if len(sys.argv) != 5:
        print("Usage: Neuron Tracing <address> <port> <uuid> <file_url>")
        exit(-1)

    address = sys.argv[1]
    port = sys.argv[2]
    uuid = sys.argv[3]
    file_url = sys.argv[4]

    os.environ['SPARK_HOME']="/home/gbw/spark-1.6.2"
    sys.path.append("/home/gbw/spark-1.6.2/python")
    try:
        from pyspark import SparkContext
        sc = SparkContext("local[*]", "Neoron Tracing")

    except ImportError as e:
        print("Can not import Spark Modules", e)
        sys.exit(1)

    t1 = datetime.datetime.now()
    # print "begin:", begin

    # file_url = "/home/gbw/PycharmProjects/DvidSpark/seeds"
    # uuid = "ae87"
    seeds = getSeeds(file_url)

    # seeds = seeds[0:3]

    address = sc.broadcast(address)
    port = sc.broadcast(port)
    uuid = sc.broadcast(uuid)

    locsegs = sc.parallelize(seeds)
    locsegs = locsegs.map(Spark_Optimize)
    locsegs = locsegs.map(lambda x: (x[11], x[0:11]))
    # locsegs = locsegs.filter(lambda x: x[0] > 0.3)
    # locsegs = locsegs.sortByKey(ascending=False)

    # optimize_locsegs = locsegs.collect()
    # writeOptimizeAns(file_url, optimize_locsegs)

    print "Tracing: "

    Neurosegs = locsegs.map(Spark_Trace)
    Neurosegs = Neurosegs.collect()

    t2 = datetime.datetime.now()

    sc.stop()
    print "Trace cost time:", t2 - t1

    SaveSwcFile(file_url, Neurosegs, seeds)




